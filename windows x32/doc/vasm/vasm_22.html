<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on January 13, 2015 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>vasm manual: 23. Interface</title>

<meta name="description" content="vasm manual: 23. Interface">
<meta name="keywords" content="vasm manual: 23. Interface">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="vasm_21.html#Trillek-TR3200-cpu-module" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="vasm_0.html#General-9" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="vasm_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="vasm_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<hr size="2">
<a name="Interface"></a>
<a name="Interface-1"></a>
<h1 class="chapter">23. Interface</h1>

<hr size="6">
<a name="Introduction"></a>
<h2 class="section">23.1 Introduction</h2>

<p>This chapter is under construction!
</p>

<p>This chapter describes some of the internals of <code>vasm</code>
 and tries to explain
what has to be done to write a cpu module, a syntax module
or an output module for <code>vasm</code>.
However if someone wants to write one, I suggest to contact me first,
so that it can be integrated into the source tree.
</p>
<p>Note that this documentation may mention explicit values when introducing
symbolic constants. This is due to copying and pasting from the source
code. These values may not be up to date and in some cases can be overridden.
Therefore do never use the absolute values but rather the symbolic
representations.
</p>

<hr size="6">
<a name="Building-vasm-1"></a>
<h2 class="section">23.2 Building vasm</h2>

<p>This section deals with the steps necessary to build the typical
<code>vasm</code> executable from the sources.
</p>
<hr size="6">
<a name="Directory-Structure"></a>
<h3 class="subsection">23.2.1 Directory Structure</h3>

<p>    The vasm-directory contains the following important files and
    directories:
</p><dl compact="compact">
<dt>    &lsquo;<tt>vasm/</tt>&rsquo;</dt>
<dd><p>The main directory containing the assembler sources.
</p>
</dd>
<dt>    &lsquo;<tt>vasm/Makefile</tt>&rsquo;</dt>
<dd><p>The Makefile used to build <code>vasm</code>.
</p>
</dd>
<dt>    &lsquo;<tt>vasm/syntax/&lt;syntax-module&gt;/</tt>&rsquo;</dt>
<dd><p>Directories for the syntax modules.
</p>
</dd>
<dt>    &lsquo;<tt>vasm/cpus/&lt;cpu-module&gt;/</tt>&rsquo;</dt>
<dd><p>Directories for the cpu modules.
</p>
</dd>
<dt> &lsquo;<tt>vasm/obj/</tt>&rsquo;</dt>
<dd><p>Directory the object modules will be stored in.
</p>
</dd>
</dl>

<p>    All compiling is done from the main directory and
    the executables will be placed there as well.
    The main assembler for a combination of <code>&lt;cpu&gt;</code> and
    <code>&lt;syntax&gt;</code> will
    be called <code>vasm&lt;cpu&gt;_&lt;syntax&gt;</code>. All output modules are
    usually integrated in every executable and can be selected at
    runtime.
</p>
<hr size="6">
<a name="Adapting-the-Makefile"></a>
<h3 class="subsection">23.2.2 Adapting the Makefile</h3>

<p>    Before building anything you have to insert correct values for
    your compiler and operating system in the &lsquo;<tt>Makefile</tt>&rsquo;.
</p>
<dl compact="compact">
<dt> <code>TARGET</code></dt>
<dd><p>       Here you may define an extension which is appended to the executable&rsquo;s
       name. Useful, if you build various targets in the same directory.
</p>
    </dd>
<dt> <code>TARGETEXTENSION</code></dt>
<dd><p>       Defines the file name extension for executable files. Not needed for
       most operating systems. For Windows it would be &lsquo;<tt>.exe</tt>&rsquo;.
</p>
    </dd>
<dt> <code>CC</code></dt>
<dd><p>       Here you have to insert a command that invokes an ANSI C
       compiler you want to use to build vasm. It must support
       the &lsquo;<samp>-I</samp>&rsquo; option the same like e.g. <code>vc</code> or
       <code>gcc</code>.
</p>
    </dd>
<dt> <code>COPTS</code></dt>
<dd><p>       Here you will usually define an option like &lsquo;<samp>-c</samp>&rsquo; to instruct
       the compiler to generate an object file.
       Additional options, like the optimization level, should also be
       inserted here as well. When the host operating system is different
       from a Unix (MacOSX and MiNT are Unix), you have to define one of the
       following preprocessor macros:
       </p><dl compact="compact">
<dt> <code>-DAMIGA</code></dt>
<dd><p>          AmigaOS (M68k or PPC), MorphOS, AROS.
          </p></dd>
<dt> <code>-DATARI</code></dt>
<dd><p>          Atari TOS.
          </p></dd>
<dt> <code>-DMSDOS</code></dt>
<dd><p>          CP/M, MS-DOS, Windows.
       </p></dd>
</dl>

    </dd>
<dt> <code>CCOUT</code></dt>
<dd><p>       Here you define the option which is used to specify the name of
       an output file, which is usually &lsquo;<samp>-o</samp>&rsquo;.
</p>
    </dd>
<dt> <code>LD</code></dt>
<dd><p>       Here you insert a command which starts the linker. This may be the
       the same as under <code>CC</code>.
</p>
    </dd>
<dt> <code>LDFLAGS</code> </dt>
<dd><p>       Here you have to add options which are necessary for linking.
       E.g. some compilers need special libraries for floating-point.
</p>
    </dd>
<dt> <code>LDOUT</code></dt>
<dd><p>       Here you define the option which is used by the linker to specify
       the output file name.
</p>
    </dd>
<dt> <code>RM</code></dt>
<dd><p>      Specify a command to delete a file, e.g. <code>rm -f</code>.
</p></dd>
</dl>

<p>    An example for the Amiga using <code>vbcc</code> would be:
</p><table><tr><td>&nbsp;</td><td><pre class="example">      TARGET = _os3
      TARGETEXTENSION =
      CC = vc +aos68k
      CCOUT = -o
      COPTS = -c -c99 -cpu=68020 -DAMIGA -O1
      LD = $(CC)
      LDOUT = $(CCOUT)
      LDFLAGS = -lmieee
      RM = delete force quiet
</pre></td></tr></table>

<p>    An example for a typical Unix-installation would be:
</p><table><tr><td>&nbsp;</td><td><pre class="example">      TARGET =
      TARGETEXTENSION =
      CC = gcc
      CCOUT = -o
      COPTS = -c -O2
      LD = $(CC)
      LDOUT = $(CCOUT)
      LDFLAGS = -lm
      RM = rm -f
</pre></td></tr></table>

<p>Open/Net/Free/Any BSD i386 systems will probably require the following
an additional &lsquo;<samp>-D_ANSI_SOURCE</samp>&rsquo; in <code>COPTS</code>.
</p>

<hr size="6">
<a name="Building-vasm"></a>
<h3 class="subsection">23.2.3 Building vasm</h3>

<p>Note to users of Open/Free/Any BSD i386 systems: You will probably have to use
GNU make instead of BSD make, i.e. in the following examples replace &quot;make&quot;
with &quot;gmake&quot;.
</p>
<p>    Type:
</p><table><tr><td>&nbsp;</td><td><pre class="example">      make CPU=&lt;cpu&gt; SYNTAX=&lt;syntax&gt;
</pre></td></tr></table>
<p>    For example:
</p><table><tr><td>&nbsp;</td><td><pre class="example">      make CPU=ppc SYNTAX=std
</pre></td></tr></table>

<p>The following CPU modules can be selected:
</p><ul>
<li> <code>CPU=6502</code>
</li><li> <code>CPU=6800</code>
</li><li> <code>CPU=arm</code>
</li><li> <code>CPU=c16x</code>
</li><li> <code>CPU=jagrisc</code>
</li><li> <code>CPU=m68k</code>
</li><li> <code>CPU=ppc</code>
</li><li> <code>CPU=test</code>
</li><li> <code>CPU=vidcore</code>
</li><li> <code>CPU=x86</code>
</li><li> <code>CPU=z80</code>
</li></ul>

<p>The following syntax modules can be selected:
</p><ul>
<li> <code>SYNTAX=std</code>
</li><li> <code>SYNTAX=mot</code>
</li><li> <code>SYNTAX=oldstyle</code>
</li><li> <code>SYNTAX=test</code>
</li></ul>

<p>For Windows and various Amiga targets there are already Makefiles included,
which you may either copy on top of the default &lsquo;<tt>Makefile</tt>&rsquo;, or call
it explicitely with <code>make</code>&rsquo;s &lsquo;<samp>-f</samp>&rsquo; option:
</p><table><tr><td>&nbsp;</td><td><pre class="example">    make -f Makefile.OS4 CPU=ppc SYNTAX=std
</pre></td></tr></table>


<hr size="6">
<a name="General-data-structures"></a>
<h2 class="section">23.3 General data structures</h2>

<p>This section describes the fundamental data structures used in vasm
which are usually necessary to understand for writing any kind of
module (cpu, syntax or output). More detailed information is given in
the respective sections on writing specific modules where necessary.
</p>
<hr size="6">
<a name="Source"></a>
<h3 class="subsection">23.3.1 Source</h3>

<p>A source structure represents a source text module, which can be
either the main source text, an included file or a macro. There is
always a link to the parent source from where the current source context
was included or called.
</p>
<dl compact="compact">
<dt> <code>struct source *parent;</code></dt>
<dd><p>        Pointer to the parent source context. Assembly continues there
        when the current source context ends.
</p>
</dd>
<dt> <code>int parent_line;</code></dt>
<dd><p>        Line number in the parent source context, from where we were called.
        This information is needed, because line numbers are only reliable
        during parsing and later from the atoms. But an include directive
        doesn&rsquo;t create an atom.
</p>
</dd>
<dt> <code>char *name;</code></dt>
<dd><p>        File name of the main source or include file, or macro name.
</p>
</dd>
<dt> <code>char *text;</code></dt>
<dd><p>        Pointer to the source text start.
</p>
</dd>
<dt> <code>size_t size;</code></dt>
<dd><p>        Size of the source text to assemble in bytes.
</p>
</dd>
<dt> <code>unsigned long repeat;</code></dt>
<dd><p>        Number of repetitions of this source text. Usually this is 1, but
        for text blocks between a <code>rept</code> and <code>endr</code> directive
        it allows any number of repetitions, which is decremented everytime
        the end of this source text block is reached.
</p>
</dd>
<dt> <code>int cond_level;</code></dt>
<dd><p>        Current level of conditional nesting while calling this macro.
        The level is provided by the syntax module through
         <code>execute_macro()</code>. The syntax module may use this information
        to restore the last valid level when exiting a macro in the middle.
</p>
</dd>
<dt> <code>int num_params;</code></dt>
<dd><p>        Number of macro parameters passed at the invocation point from
        the parent source. For normal source files this entry will be -1.
        For macros 0 (no parameters) or higher.
</p>
</dd>
<dt> <code>char *param[MAXMACPARAMS];</code></dt>
<dd><p>        Pointer to the macro parameters. Parameter 0 is usually reserved
        for a special purpose, like the mnemonic&rsquo;s first qualifier.
</p>
</dd>
<dt> <code>int param_len[MAXMACPARAMS];</code></dt>
<dd><p>        Number of characters per macro parameter.
</p>
</dd>
<dt> <code>unsigned long id;</code></dt>
<dd><p>        Every source has its unique id. Useful for macros supporting
        the special <code>\@</code> parameter.
</p>
</dd>
<dt> <code>char *srcptr;</code></dt>
<dd><p>        The current source text pointer, pointing to the beginning of
        the next line to assemble.
</p>
</dd>
<dt> <code>int line;</code></dt>
<dd><p>        Line number in the current source context. After parsing the
        line number of the current atom is stored here.
</p>
</dd>
<dt> <code>char *linebuf;</code></dt>
<dd><p>        A <code>MAXLINELENGTH</code> buffer for the current line being assembled
        in this source text. A child-source, like a macro, can refer to
        arguments from this buffer, so every source has got its own.
        When returning to the parent source, the linebuf is deallocated
        to save memory.
</p></dd>
</dl>

<hr size="6">
<a name="Sections"></a>
<h3 class="subsection">23.3.2 Sections</h3>

<p>One of the top level structures is a linked list of sections describing
continuous blocks of memory. A section is specified by an object of
type <code>section</code> with the following members that can be accessed by
the modules:
</p>
<dl compact="compact">
<dt>  <code>struct section *next;</code></dt>
<dd><p>        A pointer to the next section in the list.
</p>
</dd>
<dt>  <code>char *name;</code></dt>
<dd><p>        The name of the section.
</p>
</dd>
<dt>  <code>char *attr;</code></dt>
<dd><p>        A string describing the section flags in ELF notation (see,
        for example, documentation o the <code>.section</code> directive of
        the standard syntax mopdule.
</p>
</dd>
<dt>  <code>atom *first;</code></dt>
<dt> <code>atom *last;</code></dt>
<dd><p>        Pointers to the first and last atom of the section. See following
        sections for information on atoms.
</p>
</dd>
<dt>  <code>taddr align;</code></dt>
<dd><p>        Alignment of the section in bytes.
</p>
</dd>
<dt>  <code>uint32_t flags;</code></dt>
<dd><p>        Flags of the section. Currently available flags are:
</p><dl compact="compact">
<dt> <code>HAS_SYMBOLS</code></dt>
<dd><p>        At least one symbol is defined in this section.
</p></dd>
<dt> <code>RESOLVE_WARN</code></dt>
<dd><p>        The current atom changed its size multiple times, so atom_size()
        is now called with this flag set in its section to make the
        backend (e.g. <code>instruction_size()</code>) aware of it and do less
        aggressive optimizations.
</p></dd>
<dt> <code>UNALLOCATED</code></dt>
<dd><p>        Section is unallocated, which means it doesn&rsquo;t use any memory space
        in the output file. Such a section will be removed before creating
        the output file and all its labels converted into absolute expression
        symbols. Used for &quot;offset&quot; sections. Refer to
        <code>switch_offset_section()</code>.
</p></dd>
<dt> <code>LABELS_ARE_LOCAL</code></dt>
<dd><p>        As long as this flag is set new labels in a section are defined
        as local labels, with the section name as global parent label.
</p></dd>
<dt> <code>ABSOLUTE</code></dt>
<dd><p>        Section is loaded at an absolute address in memory.
</p></dd>
</dl>

</dd>
<dt>  <code>taddr org;</code></dt>
<dd><p>        Start address of a section. Usually zero.
</p>
</dd>
<dt>  <code>taddr pc;</code></dt>
<dd><p>        Current address in this section. Can be used
        while traversing through the section. Has to be updated by a
        module using it. Is set to <code>org</code> at the beginning.
</p>
</dd>
<dt>   <code>uint32_t idx;</code></dt>
<dd><p>        A member usable by the output module for private purposes.
</p>
</dd>
</dl>

<hr size="6">
<a name="Symbols"></a>
<h3 class="subsection">23.3.3 Symbols</h3>

<p>Symbols are represented by a linked list of type <code>symbol</code> with the
following members that can be accessed by the modules:.
</p>
<dl compact="compact">
<dt>  <code>int type;</code></dt>
<dd><p>        Type of the symbol. Available are:
</p><dl compact="compact">
<dt> <code>#define LABSYM 1</code></dt>
<dd><p>        The symbol is a label defined at a specific location.
</p>
</dd>
<dt> <code>#define IMPORT 2</code></dt>
<dd><p>        The symbol is imported from another file.
</p>
</dd>
<dt> <code>#define EXPRESSION 3</code></dt>
<dd><p>        The symbol is defined using an expression.
</p></dd>
</dl>

</dd>
<dt>  <code>uint32_t flags;</code></dt>
<dd><p>        Flags of this symbol. Available are:
</p><dl compact="compact">
<dt> <code>#define TYPE_UNKNOWN  0</code></dt>
<dd><p>        The symbol has no type information.
</p>
</dd>
<dt> <code>#define TYPE_OBJECT   1</code></dt>
<dd><p>        The symbol defines an object.
</p>
</dd>
<dt> <code>#define TYPE_FUNCTION 2</code></dt>
<dd><p>        The symbol defines a function.
</p>
</dd>
<dt> <code>#define TYPE_SECTION  3</code></dt>
<dd><p>        The symbol defines a section.
</p>
</dd>
<dt> <code>#define TYPE_FILE     4</code></dt>
<dd><p>      The symbol defines a file.  
</p>
</dd>
<dt> <code>#define EXPORT (1&lt;&lt;3)</code></dt>
<dd><p>        The symbol is exported to other files.
</p>
</dd>
<dt> <code>#define INEVAL (1&lt;&lt;4)</code></dt>
<dd><p>        Used internally.
</p>
</dd>
<dt> <code>#define COMMON (1&lt;&lt;5)</code></dt>
<dd><p>        The symbol is a common symbol.
</p>
</dd>
<dt> <code>#define WEAK (1&lt;&lt;6)</code></dt>
<dd><p>        The symbol is weak, which means the linker may overwrite it with
        any global definition of the same name. Weak symbols may also stay
        undefined, in which case the linker would assign them a value of
        zero.
</p>
</dd>
<dt> <code>#define VASMINTERN (1&lt;&lt;7)</code></dt>
<dd><p>        Vasm-internal symbol, which is usually not exported into an output
        file.
</p>
</dd>
<dt> <code>#define PROTECTED (1&lt;&lt;8)</code></dt>
<dd><p>        Used internally to protect the current-PC symbol from deletion.
</p>
</dd>
<dt> <code>#define REFERENCED (1&lt;&lt;9)</code></dt>
<dd><p>        Symbol was referenced in the source and a relocation entry has
        been created.
</p>
</dd>
<dt> <code>#define RSRVD_S (1L&lt;&lt;24)</code></dt>
<dd><p>        The range from bit 24 to 27 (counted from the LSB) is reserved for
        use by the syntax module.
</p>
</dd>
<dt> <code>#define RSRVD_O (1L&lt;&lt;28)</code></dt>
<dd><p>        The range from bit 28 to 31 (counted from the LSB) is reserved for
        use by the output module.
</p></dd>
</dl>

<p>The type-flags can be extracted using the <code>TYPE()</code> macro which
expects a pointer to a symbol as argument.
</p>
</dd>
<dt>  <code>char *name;</code></dt>
<dd><p>        The name of the symbol.
</p>
</dd>
<dt>   <code>expr *expr;</code></dt>
<dd><p>        The expression in case of <code>EXPRESSION</code> symbols.
</p>
</dd>
<dt>   <code>expr *size;</code></dt>
<dd><p>        The size of the symbol, if specified.
</p>
</dd>
<dt>  <code>section *sec;</code></dt>
<dd><p>        The section a <code>LABSYM</code> symbol is defined in.
</p>
</dd>
<dt>  <code>taddr pc;</code></dt>
<dd><p>        The address of a <code>LABSYM</code> symbol.
</p>
</dd>
<dt>  <code>taddr align;</code></dt>
<dd><p>        The alignment of the symbol in bytes.
</p>
</dd>
<dt>  <code>uint32_t idx;</code></dt>
<dd><p>        A member usable by the output module for private purposes.
</p>
</dd>
</dl>

<hr size="6">
<a name="Register-symbols"></a>
<h3 class="subsection">23.3.4 Register symbols</h3>

<p>Optional register symbols are available when the backend defines
<code>HAVE_REGSYMS</code> in &lsquo;<tt>cpu.h</tt>&rsquo; together with the hash table size.
Example:
</p><table><tr><td>&nbsp;</td><td><pre class="example">#define HAVE_REGSYMS
#define REGSYMHTSIZE 256
</pre></td></tr></table>

<p>A register symbol is defined by an object of type <code>regsym</code>
with the following members that can be accessed by the modules:
</p>
<dl compact="compact">
<dt> <code>char *reg_name;</code></dt>
<dd><p>      Symbol name.
</p></dd>
<dt> <code>int reg_type;</code></dt>
<dd><p>      Optional type of register.
</p></dd>
<dt> <code>unsigned int reg_flags;</code></dt>
<dd><p>      Optional register symbol flags.
</p></dd>
<dt> <code>unsigned int reg_num;</code></dt>
<dd><p>      Register number or value.
</p></dd>
</dl>

<p>Refer to &lsquo;<tt>symbol.h</tt>&rsquo; for functions to create and find register
symbols.
</p>
<hr size="6">
<a name="Atoms"></a>
<h3 class="subsection">23.3.5 Atoms</h3>

<p>The contents of each section are a linked list built out of non-separable
atoms. The general structure of an atom is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct atom {
  struct atom *next;
  int type;
  taddr align;
  taddr lastsize;
  unsigned changes;
  source *src;
  int line;
  listing *list;
  union {
    instruction *inst;
    dblock *db;
    symbol *label;
    sblock *sb;
    defblock *defb;
    void *opts;
    int srcline;
    char *ptext;
    expr *pexpr;
    expr *roffs;
    taddr *rorg;
    assertion *assert;
  } content;
} atom;
</pre></td></tr></table>

<p>The members have the following meaning:
</p>
<dl compact="compact">
<dt>  <code>struct atom *next;</code></dt>
<dd><p>Pointer to the following atom (0 if last).
</p>
</dd>
<dt>  <code>int type;</code></dt>
<dd><p>The type of the atom. Can be one of
</p><dl compact="compact">
<dt> <code>#define LABEL 1</code></dt>
<dd><p>A label is defined here.
</p>
</dd>
<dt> <code>#define DATA  2</code></dt>
<dd><p>Some data bytes of fixed length and constant data are put here.
</p>
</dd>
<dt> <code>#define INSTRUCTION 3</code></dt>
<dd><p>Generally refers to a machine instruction or pseudo/opcode. These atoms
can change length during optimization passes and will be translated to
<code>DATA</code>-atoms later.
</p>
</dd>
<dt> <code>#define SPACE 4</code></dt>
<dd><p>Defines a block of data filled with one value (byte). BSS sections usually
contain only such atoms, but they are also sometimes useful as shorter
versions of <code>DATA</code>-atoms in other sections.
</p>
</dd>
<dt> <code>#define DATADEF 5</code></dt>
<dd><p>Defines data of fixed size which can contain cpu specific operands and
expressions. Will be translated to <code>DATA</code>-atoms later.
</p>
</dd>
<dt> <code>#define LINE 6</code></dt>
<dd><p>A source text line number (usually from a high level language) is bound
to the atom&rsquo;s address. Useful for source level debugging in certain ABIs.
</p>
</dd>
<dt> <code>#define OPTS 7</code></dt>
<dd><p>A means to change assembler options at a specific source text line.
For example optimization settings, or the cpu type to generate code for.
The cpu module has to define <code>HAVE_CPU_OPTS</code> and export the required
functions if it wants to use this type of atom.
</p>
</dd>
<dt> <code>#define PRINTTEXT 8</code></dt>
<dd><p>A string is printed to stdout during the final assembler pass. A newline
is automatically appended.
</p>
</dd>
<dt> <code>#define PRINTEXPR 9</code></dt>
<dd><p>Prints the value of an expression during the final assembler pass to stdout.
</p>
</dd>
<dt> <code>#define ROFFS 10</code></dt>
<dd><p>Set the program counter to an address relative to the section&rsquo;s start
address. These atoms will be translated into <code>SPACE</code> atoms in the
final pass.
</p>
</dd>
<dt> <code>#define RORG 11</code></dt>
<dd><p>Assemble this block under the given base address, while the code is still
written into the original memory region.
</p>
</dd>
<dt> <code>#define RORGEND 12</code></dt>
<dd><p>Ends a RORG block and returns to the original addessing.
</p>
</dd>
<dt> <code>#define ASSERT 13</code></dt>
<dd><p>The assertion expression is checked in the final pass and an error message
is generated (using the expression string and an optional message out of
this atom) when it evaluates to 0.
</p>
</dd>
</dl>

</dd>
<dt> <code>taddr align;</code></dt>
<dd><p>The alignment of this atom. Address must be dividable by <code>align</code>.
</p>
</dd>
<dt> <code>taddr lastsize;</code></dt>
<dd><p>The size of this atom in the last resolver pass. When the size has
changed in the current pass, the assembler will request another resolver
run through the section.
</p>
</dd>
<dt> <code>unsigned changes;</code></dt>
<dd><p>Number of changes in the size of this atom since pass number
<code>FASTOPTPHASE</code>. An increasing number usually indicates a problem in
the cpu backend&rsquo;s optimizer and will be flagged by setting
<code>RESOLVE_WARN</code> in the Section flags, as soon as <code>changes</code> exceeds
<code>MAXSIZECHANGES</code>. So the backend can choose not to optimize this atom
as aggressive as before.
</p>
</dd>
<dt> <code>source *src;</code></dt>
<dd><p>Pointer to the source text object to which this atom belongs.
</p>
</dd>
<dt>  <code>int line;</code></dt>
<dd><p>The source line number that created this atom.
</p>
</dd>
<dt> <code>listing *list;</code></dt>
<dd><p>Pointer to the listing object to which this atoms belong.
</p>
</dd>
<dt>    <code>instruction *inst;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to an instruction structure in the case
of an <code>INSTRUCTION</code>-atom. Contains the following elements:
</p><dl compact="compact">
<dt>  <code>int code;</code></dt>
<dd><p>The cpu specific code of this instruction.
</p>
</dd>
<dt>  <code>char *qualifiers[MAX_QUALIFIERS];</code></dt>
<dd><p>(If <code>MAX_QUALIFIERS!=0</code>.) Pointer to the qualifiers of this instruction.
</p>
</dd>
<dt>  <code>operand *op[MAX_OPERANDS];</code></dt>
<dd><p>(If <code>MAX_OPERANDS!=0</code>.) The cpu-specific operands of this instruction.
</p>
</dd>
<dt>  <code>instruction_ext ext;</code></dt>
<dd><p>(If the cpu module defines <code>HAVE_INSTRUCTION_EXTENSION</code>.)
A cpu-module-specific structure. Typically used to store appropriate
opcodes, allowed addressing modes, supported cpu derivates etc.
</p></dd>
</dl>

</dd>
<dt>    <code>dblock *db;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to a dblock structure in the case
of a <code>DATA</code>-atom. Contains the following elements:
</p><dl compact="compact">
<dt>  <code>taddr size;</code></dt>
<dd><p>The number of bytes stored in this atom.
</p>
</dd>
<dt>  <code>char *data;</code></dt>
<dd><p>A pointer to the data.
</p>
</dd>
<dt>  <code>rlist *relocs;</code></dt>
<dd><p>A pointer to relocation information for the data.
</p></dd>
</dl>

</dd>
<dt>    <code>symbol *label;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to a symbol structure in the case
of a <code>LABEL</code>-atom.
</p>
</dd>
<dt>    <code>sblock *sb;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to a sblock structure in the case
of a <code>SPACE</code>-atom. Contains the following elements:
</p><dl compact="compact">
<dt>  <code>taddr space;</code></dt>
<dd><p>The size of the empty/filled space in bytes.
</p>
</dd>
<dt> <code>expr *space_exp;</code></dt>
<dd><p>The above size as an expression, which will be evaluated during assembly
and copied to <code>space</code> in the final pass.
</p>
</dd>
<dt>  <code>int size;</code></dt>
<dd><p>The size of each space-element and of the fill-pattern in bytes.
</p>
</dd>
<dt>  <code>unsigned char fill[MAXBYTES];</code></dt>
<dd><p>The fill pattern, up to MAXBYTES bytes.
</p>
</dd>
<dt> <code>expr *fill_exp;</code></dt>
<dd><p>Optional. Evaluated and copied to <code>fill</code> in the final pass, when not null.
</p>
</dd>
<dt> <code>rlist *relocs;</code></dt>
<dd><p>A pointer to relocation information for the space.
</p>
</dd>
<dt> <code>taddr maxalignbytes;</code></dt>
<dd><p>An optional number of maximum padding bytes to fulfil the atom&rsquo;s alignment
requirement. Zero means there is no restriction.
</p></dd>
</dl>

</dd>
<dt>    <code>defblock *defb;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to a defblock structure in the case
of a <code>DATADEF</code>-atom. Contains the following elements:
</p><dl compact="compact">
<dt>  <code>taddr bitsize;</code></dt>
<dd><p>The size of the definition in bits.
</p>
</dd>
<dt>  <code>operand *op;</code></dt>
<dd><p>Pointer to a cpu-specific operand structure.
</p>
</dd>
</dl>

</dd>
<dt>    <code>void *opts;</code></dt>
<dd><p>(In union <code>content</code>.) Points to a cpu module specific options object
in the case of a <code>OPTS</code>-atom.
</p>
</dd>
<dt>    <code>int srcline;</code></dt>
<dd><p>(In union <code>content</code>.) Line number for source level debugging in the
case of a <code>LINE</code>-atom.
</p>
</dd>
<dt>    <code>char *ptext;</code></dt>
<dd><p>(In union <code>content</code>.) A string to print to stdout in case of a
<code>PRINTTEXT</code>-atom.
</p>
</dd>
<dt>    <code>expr *pexpr;</code></dt>
<dd><p>(In union <code>content</code>.) An expression to evaluate and print to stdout in
case of a <code>PRINTEXPR</code>-atom.
</p>
</dd>
<dt>    <code>expr *roffs;</code></dt>
<dd><p>(In union <code>content</code>.) The expression holds the relative section offset
to align to in case of a <code>ROFFS</code>-atom.
</p>
</dd>
<dt>    <code>taddr *rorg;</code></dt>
<dd><p>(In union <code>content</code>.) Assemble the code under the base address in
<code>rorg</code> in case of a <code>RORG</code>-atom.
</p>
</dd>
<dt>    <code>assertion *assert;</code></dt>
<dd><p>(In union <code>content</code>.) Pointer to an assertion structure in the case of
an <code>ASSERT</code>-atom. Contains the following elements:
</p><dl compact="compact">
<dt> <code>expr *assert_exp;</code></dt>
<dd><p>Pointer to an expression which should evaluate to non-zero.
</p>
</dd>
<dt> <code>char *exprstr;</code></dt>
<dd><p>Pointer to the expression as text (to be used in the output).
</p>
</dd>
<dt> <code>char *msgstr;</code></dt>
<dd><p>Pointer to the message, which would be printed when <code>assert_exp</code> evaluates
to zero.
</p>
</dd>
</dl>

</dd>
</dl>

<hr size="6">
<a name="Relocations"></a>
<h3 class="subsection">23.3.6 Relocations</h3>

<p><code>DATA</code> and <code>SPACE</code> atoms can have a relocation list attached
that describes how this data must be modified when linking/relocating.
They always refer to the data in this atom only.
</p>
<p>There are a number of predefined standard relocations and it is possible
to add other cpu-specific relocations. Note however, that it is always
preferrable to use standard relocations, if possible. Chances that an
output module supports a certain relocation are much higher if it is a
standard relocation.
</p>
<p>A relocation list uses this structure:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct rlist {
  struct rlist *next;
  void *reloc;
  int type;
} rlist;
</pre></td></tr></table>

<p>Type identifies the relocation type. All the standard relocations have
type numbers between <code>FIRST_STANDARD_RELOC</code> and 
<code>LAST_STANDARD_RELOC</code>. Consider &lsquo;<tt>reloc.h</tt>&rsquo; to see which
standard relocations are available.
</p>
<p> The detailed information can be accessed
via the pointer <code>reloc</code>. It will point to a structure that depends
on the relocation type, so a module must only use it if it knows the
relocation type.
</p>
<p>All standard relocations point to a type <code>nreloc</code> with the following
members:
</p><dl compact="compact">
<dt>  <code>int offset;</code></dt>
<dd><p>The offset (from the start of the <code>DATA</code>-atom in bits.
</p>        
</dd>
<dt>  <code>int size;</code></dt>
<dd><p>The size of the relocation in bits.
</p>
</dd>
<dt>  <code>taddr mask;</code> </dt>
<dd><p>A mask value.
</p>
</dd>
<dt> <code>taddr addend;</code></dt>
<dd><p>Value to be added to the symbol value.
</p>
</dd>
<dt>  <code>symbol *sym;</code></dt>
<dd><p>The symbol referred by this relocation
</p>
</dd>
</dl>

<p>To describe the meaning of these entries, we will define the steps that
shall be performed when performing a relocation:
</p>
<ol>
<li> Extract the <code>size</code> bits from the data atom, starting with bit
        number <code>offset</code>. An <code>offset</code> of zero means starting with
        the first bit (MSB).

</li><li> Determine the relocation value of the symbol. For a simple absolute
        relocation, this will be the value of the symbol <code>sym</code> plus the
        <code>addend</code>. For other relocation types, more complex calculations
        will be needed. For example, in a program-counter relative relocation,
        the value will be obtained by subtracting the address of the data
        atom (possibly offset by a target specific value) from the value
        of <code>sym</code> plus <code>addend</code>.

</li><li> Calculate the bit-wise &quot;and&quot; of the value obtained in the step above
        and the <code>mask</code> value.

</li><li> Normalize, i.e. shift the value above right as many bit positions as
        there are low order zero bits in <code>mask</code>.

</li><li> Add this value to the value extracted in step 1.

</li><li> Insert the low order <code>size</code> bits of this value into the data atom
        starting with bit <code>offset</code>.
</li></ol>


<hr size="6">
<a name="Errors"></a>
<h3 class="subsection">23.3.7 Errors</h3>

<p>Each module can provide a list of possible error messages contained
e.g. in &lsquo;<tt>syntax_errors.h</tt>&rsquo; or &lsquo;<tt>cpu_errors.h</tt>&rsquo;. They are a
comma-separated list of a printf-format string and error flags. Allowed
flags are <code>WARNING</code>, <code>ERROR</code>, <code>FATAL</code> and <code>NOLINE</code>.
They can be combined using or (<code>|</code>). <code>NOLINE</code> has to be set for
error messages during initialiation or while writing the output, when
no source text is available. Errors cause the assembler to return false.
<code>FATAL</code> causes the assembler to terminate
immediately.
</p>
<p>The errors can be emitted using the function <code>syntax_error(int n,...)</code>,
<code>cpu_error(int n,...)</code> or <code>output_error(int n,...)</code>. The first
argument is the number of the error message (starting from zero). Additional
arguments must be passed according to the format string of the
corresponding error message.
</p>
<hr size="6">
<a name="Syntax-modules"></a>
<h2 class="section">23.4 Syntax modules</h2>

<p>A new syntax module must have its own subdirectory under &lsquo;<tt>vasm/syntax</tt>&rsquo;.
At least the files &lsquo;<tt>syntax.h</tt>&rsquo;, &lsquo;<tt>syntax.c</tt>&rsquo; and &lsquo;<tt>syntax_errors.h</tt>&rsquo;
must be written.
</p>
<hr size="6">
<a name="The-file-syntax_002eh"></a>
<h3 class="subsection">23.4.1 The file &lsquo;<tt>syntax.h</tt>&rsquo;</h3>

<dl compact="compact">
<dt> <code>#define ISIDSTART(x)/ISIDCHAR(x)</code></dt>
<dd><p>These macros should return non-zero if and only if the argument is a
valid character to start an identifier or a valid character inside an
identifier, respectively.
<code>ISIDCHAR</code> must be a superset of <code>ISIDSTART</code>.
</p>
</dd>
<dt> <code>#define CHKIDEND(s,e) chkidend((s),(e))</code></dt>
<dd><p>Defines an optional function to be called at the end of the identifier
recognition process. It allows you to adjust the length of the identifier
by returning a modified <code>e</code>. Default is to return <code>e</code>. The
function is defined as <code>char *chkidend(char *startpos,char *endpos)</code>.
</p>
</dd>
<dt> <code>#define NARGSYM &quot;NARG&quot;</code></dt>
<dd><p>Defines the name of an optional symbol which contains the number of
arguments in a macro.
</p>
</dd>
<dt> <code>#define CARGSYM &quot;CARG&quot;</code></dt>
<dd><p>Defines the name of an optional symbol which can be used to select a
specific macro argument with <code>\.</code>, <code>\+</code> and <code>\-</code>.
</p>
</dd>
<dt> <code>#define REPTNSYM &quot;REPTN&quot;</code></dt>
<dd><p>Defines the name of an optional symbol containing the counter of the
current repeat iteration.
</p>
</dd>
<dt> <code>#define EXPSKIP() s=exp_skip(s)</code></dt>
<dd><p>Defines an optional replacement for skip() to be used in expr.c, to skip
blanks in an expression. Useful to forbid blanks in an expression and to
ignore the rest of the line (e.g. to treat the rest as comment). The
function is defined as <code>char *exp_skip(char *stream)</code>.
</p>
</dd>
<dt> <code>#define IGNORE_FIRST_EXTRA_OP 1</code></dt>
<dd><p>Should be defined when the syntax module wants to ignore the operand field
on instructions without an operand. Useful, when everything following
an operand should be regarded as comment, without a comment character.
</p>
</dd>
</dl>

<hr size="6">
<a name="The-file-syntax_002ec"></a>
<h3 class="subsection">23.4.2 The file &lsquo;<tt>syntax.c</tt>&rsquo;</h3>

<p>A syntax module has to provide the following elements (all other funtions
should be <code>static</code> to prevent name clashes):
</p>
<dl compact="compact">
<dt> <code>char *syntax_copyright;</code></dt>
<dd><p>A string that will be emitted as part of the copyright message.
</p>
</dd>
<dt> <code>hashtable *dirhash;</code></dt>
<dd><p>A pointer to the hash table with all directives.
</p>
</dd>
<dt> <code>char commentchar;</code></dt>
<dd><p>A character used to introduce a comment until the end of the line.
</p>
</dd>
<dt> <code>char *defsectname;</code></dt>
<dd><p>Name of a default section which vasm creates when a label or code occurs
in the source, but the programmer forgot to specify a section. Assigning
NULL means that there is no default and vasm will show an error in this
case.
</p>
</dd>
<dt> <code>char *defsecttype;</code></dt>
<dd><p>Type of the default section (see above). May be NULL.
</p>
</dd>
<dt> <code>int init_syntax();</code></dt>
<dd><p>Will be called during startup, after argument parsing Must return zero if
initializations failed, non-zero otherwise.
</p>
</dd>
<dt> <code>int syntax_args(char *);</code></dt>
<dd><p>This function will be called with the command line arguments (unless they
were already recognized by other modules). If an argument was recognized,
return non-zero.
</p>
</dd>
<dt> <code>char *skip(char *);</code></dt>
<dd><p>A function to skip whitespace etc.
</p>
</dd>
<dt> <code>char *skip_operand(char *);</code></dt>
<dd><p>A function to skip an instruction&rsquo;s operand. Will terminate at end of line
or the next comma, returning a pointer to the rest of the line behind
the comma.
</p>
</dd>
<dt> <code>void eol(char *);</code></dt>
<dd><p>This function should check that the argument points to the end of a line
(only comments or whitespace following). If not, an error or warning
message should be omitted.
</p>
</dd>
<dt> <code>char *const_prefix(char *,int *);</code></dt>
<dd><p>Check if the first argument points to the start of a constant. If yes
return a pointer to the real start of the number (i.e. skip a prefix
that may indicate the base) and write the base of the number through the
pointer passed as second argument. Return zero if it does not point to a
number.
</p>
</dd>
<dt> <code>char *const_suffix(char *,char *);</code></dt>
<dd><p>First argument points to the start of the constant (including prefix) and
the second argument to first character after the constant (excluding suffix).
Checks for a constant-suffix and skips it. Return pointer to the first
character after that constant. Example: constants with a &rsquo;h&rsquo; suffix to
indicate a hexadecimal base.
</p>
</dd>
<dt> <code>void parse(void);</code></dt>
<dd><p>This is the main parsing function. It has to read lines via
the <code>read_next_line()</code> function, parse them and create sections,
atoms and symbols. Pseudo directives are usually handled by the syntax 
module. Instructions can be parsed by the cpu module using
<code>parse_instruction()</code>.
</p>
</dd>
<dt> <code>char *get_local_label(char **);</code></dt>
<dd><p>Gets a pointer to the current source pointer. Has to check if a valid
local label is found at this point. If yes return a pointer to the
vasm-internal symbol name representing the local label and update
the current source pointer to point behind the label.
</p>
<p>Have a look at the support functions provided by the frontend to help.
</p>
</dd>
</dl>

<hr size="6">
<a name="CPU-modules"></a>
<h2 class="section">23.5 CPU modules</h2>

<p>A new cpu module must have its own subdirectory under &lsquo;<tt>vasm/cpus</tt>&rsquo;.
At least the files &lsquo;<tt>cpu.h</tt>&rsquo;, &lsquo;<tt>cpu.c</tt>&rsquo; and &lsquo;<tt>cpu_errors.h</tt>&rsquo;
must be written.
</p>
<hr size="6">
<a name="The-file-cpu_002eh"></a>
<h3 class="subsection">23.5.1 The file &lsquo;<tt>cpu.h</tt>&rsquo;</h3>

<p>A cpu module has to provide the following elements (all other functions
should be <code>static</code> to prevent name clashes) in <code>cpu.h</code>:
</p>
<dl compact="compact">
<dt> <code>#define MAX_OPERANDS 3</code></dt>
<dd><p>Maximum number of operands of one instruction.
</p>
</dd>
<dt> <code>#define MAX_QUALIFIERS 0</code></dt>
<dd><p>Maximum number of mnemonic-qualifiers per mnemonic.
</p>
</dd>
<dt> <code>typedef int32_t taddr;</code></dt>
<dd><p>Data type to represent a target-address. Preferrably use the ones from
&lsquo;<tt>stdint.h</tt>&rsquo;.
</p>
</dd>
<dt> <code>typedef uint32_t utaddr;</code></dt>
<dd><p>Unsigned data type to represent a target-address.
</p>
</dd>
<dt> <code>#define LITTLEENDIAN 1</code></dt>
<dt> <code>#define BIGENDIAN 0</code></dt>
<dd><p>Define these according to the target endianess. For CPUs which support big-
and little-endian, you may assign a global variable here. So be aware of
it, and never use <code>#if BIGENDIAN</code>, but always <code>if(BIGENDIAN)</code> in
your code.
</p>
</dd>
<dt> <code>#define VASM_CPU_&lt;cpu&gt; 1</code></dt>
<dd><p>Insert the cpu specifier.
</p>
</dd>
<dt> <code>#define INST_ALIGN 2</code></dt>
<dd><p>Minimum instruction alignment.
</p>
</dd>
<dt> <code>#define DATA_ALIGN(n) ...</code></dt>
<dd><p>Default alignment for <code>n</code>-bit data. Can also be a function.
</p>
</dd>
<dt> <code>#define DATA_OPERAND(n) ...</code></dt>
<dd><p>Operand class for n-bit data definitions. Can also be a function.
Negative values denote a floating point data definition of -n bits.
</p>
</dd>
<dt> <code>typedef ... operand;</code></dt>
<dd><p>Structure to store an operand.
</p>
</dd>
<dt> <code>typedef ... mnemonic_extension;</code></dt>
<dd><p>Mnemonic extension.
</p></dd>
</dl>

<p>Optional features, which can be enabled by defining the following macros:
</p>
<dl compact="compact">
<dt> <code>#define HAVE_INSTRUCTION_EXTENSION 1</code></dt>
<dd><p>If cpu-specific data should be added to all instruction atoms.
</p>
</dd>
<dt> <code>typedef ... instruction_ext;</code></dt>
<dd><p>Type for the above extension.
</p>
</dd>
<dt> <code>#define NEED_CLEARED_OPERANDS 1</code></dt>
<dd><p>Backend requires a zeroed operand structure when calling <code>parse_operand()</code>
for the first time. Defaults to undefined.
</p>
</dd>
<dt> <code>START_PARENTH(x)</code></dt>
<dd><p>Valid opening parenthesis for instruction operands. Defaults to <code>'('</code>.
</p>
</dd>
<dt> <code>END_PARENTH(x)</code></dt>
<dd><p>Valid closing parenthesis for instruction operands. Defaults to <code>')'</code>.
</p>
</dd>
<dt> <code>#define MNEMONIC_VALID(i)</code></dt>
<dd><p>An optional function with the arguments <code>(int idx)</code>. Returns true
when the mnemonic with index <code>idx</code> is valid for the current state of
the backend (e.g. it is available for the selected cpu architecture).
</p>
</dd>
<dt> <code>#define OPERAND_OPTIONAL(p,t)</code></dt>
<dd><p>When defined, this is a function with the arguments
<code>(operand *op,int type)</code>, which returns true when the given operand
type (<code>type</code>) is optional. The function is only called for missing
operands and should also initialize <code>op</code> with default values (e.g. 0).
</p></dd>
</dl>

<p>Implementing additional target-specific unary operations is done by defining
the following optional macros:
</p>
<dl compact="compact">
<dt> <code>#define EXT_UNARY_NAME(s)</code></dt>
<dd><p>Should return True when the string in <code>s</code> points to an operation name
we want to handle.
</p>
</dd>
<dt> <code>#define EXT_UNARY_TYPE(s)</code></dt>
<dd><p>Returns the operation type code for the string in <code>s</code>. Note that the
last valid standard operation is defined as <code>LAST_EXP_TYPE</code>, so the
target-specific types will start with <code>LAST_EXP_TYPE+1</code>.
</p>
</dd>
<dt> <code>#define EXT_UNARY_EVAL(t,v,r,c)</code></dt>
<dd><p>Defines a function with the arguments <code>(int t, taddr v, taddr *r, int c)</code>
to handle the operation type <code>t</code> returning an <code>int</code> to indicate
whether this type has been handled or not. Your operation will by applied on
the value <code>v</code> and the result is stored in <code>*r</code>. The flag <code>c</code>
is passed as 1 when the value is constant (no relocatable addresses involved).
</p>
</dd>
<dt> <code>#define EXT_FIND_BASE(b,e,s,p)</code></dt>
<dd><p>Defines a function with the arguments
<code>(symbol **b, expr *e, section *s, taddr p)</code>
to save a pointer to the base symbol of expression <code>e</code> into the
symbol pointer, pointed to by <code>b</code>. The type of this base is given
by an <code>int</code> return code. Further on, <code>e-&gt;type</code> has to checked
to be one of the operations to handle.
The section pointer <code>s</code> and the current pc <code>p</code> are needed to call
the standard <code>find_base()</code> function.
</p></dd>
</dl>

<hr size="6">
<a name="The-file-cpu_002ec"></a>
<h3 class="subsection">23.5.2 The file &lsquo;<tt>cpu.c</tt>&rsquo;</h3>

<p>A cpu module has to provide the following elements (all other functions
and data should be <code>static</code> to prevent name clashes) in <code>cpu.c</code>:
</p>
<dl compact="compact">
<dt> <code>int bitsperbyte;</code></dt>
<dd><p>The number of bits per byte of the target cpu.
</p>
</dd>
<dt> <code>int bytespertaddr;</code></dt>
<dd><p>The number of bytes per <code>taddr</code>.
</p>
</dd>
<dt> <code>char *cpu_copyright;</code></dt>
<dd><p>A string that will be emitted as part of the copyright message.
</p>
</dd>
<dt> <code>char *cpuname;</code></dt>
<dd><p>A string describing the target cpu.
</p>
</dd>
<dt> <code>int init_cpu();</code></dt>
<dd><p>Will be called during startup, after argument parsing. Must return zero if
initializations failed, non-zero otherwise.
</p>
</dd>
<dt> <code>int cpu_args(char *);</code></dt>
<dd><p>This function will be called with the command line arguments (unless they
were already recognized by other modules). If an argument was recognized,
return non-zero.
</p>
</dd>
<dt> <code>char *parse_cpu_special(char *);</code></dt>
<dd><p>This function will be called with a source line as argument and allows
the cpu module to handle cpu-specific directives etc. Functions like
<code>eol()</code> and <code>skip()</code> should be used by the syntax module to
keep the syntax consistent.
</p>
</dd>
<dt> <code>operand *new_operand();</code></dt>
<dd><p>Allocate and initialize a new operand structure.
</p>
</dd>
<dt> <code>void free_operand(operand *);</code></dt>
<dd><p>Free an operand.
</p>
</dd>
<dt> <code>int parse_operand(char *text,int len,operand *out,int requires);</code></dt>
<dd><p>Parses the source at <code>text</code> with length <code>len</code> to fill the target
specific operand structure pointed to by <code>out</code>. Returns <code>PO_MATCH</code>
when the operand matches the operand-type passed in <code>requires</code> and
<code>PO_NOMATCH</code> otherwise. When the source is definitely identified as
garbage, the function may return <code>PO_CORRUPT</code> to tell the assembler
that it is useless to try matching against any other operand types.
Another special case is <code>PO_SKIP</code>, which is also a match, but skips
the next operand from the mnemonic table (because it was already handled
together with the current operand).
</p>
</dd>
<dt> <code>mnemonic mnemonics[];</code></dt>
<dd><p>The mnemonic table keeps a list of mnemonic names and operand types the
assembler will match against using <code>parse_operand()</code>. It may also
include a target specific <code>mnemonic_extension</code>.
</p>
</dd>
<dt> <code>taddr instruction_size(instruction *ip, section *sec, taddr pc);</code></dt>
<dd><p>Returns the size of the instruction <code>ip</code> in bytes, which must be
identical to the number of bytes written by <code>eval_instruction()</code>
(see below).
</p>
</dd>
<dt> <code>dblock *eval_instruction(instruction *ip, section *sec, taddr pc);</code></dt>
<dd><p>Converts the instruction <code>ip</code> into a DATA atom, including relocations,
if necessary.
</p>
</dd>
<dt> <code>dblock *eval_data(operand *op, taddr bitsize, section *sec, taddr pc);</code></dt>
<dd><p>Converts a data operand into a DATA atom, including relocations.
</p>
</dd>
<dt> <code>void init_instruction_ext(instruction_ext *);</code></dt>
<dd><p>(If <code>HAVE_INSTRUCTION_EXTENSION</code> is set.)
Initialize an instruction extension.
</p>
</dd>
<dt> <code>char *parse_instruction(char *,int *,char **,int *,int *);</code></dt>
<dd><p>(If <code>MAX_QUALIFIERS</code> is greater than 0.)
Parses instruction and saves extension locations.
</p>
</dd>
<dt> <code>int set_default_qualifiers(char **,int *);</code></dt>
<dd><p>(If <code>MAX_QUALIFIERS</code> is greater than 0.)
Saves pointers and lengths of default qualifiers for the selected CPU and
returns the number of default qualifiers. Example: for a M680x0 CPU this
would be a single qualifier, called &quot;w&quot;. Used by <code>execute_macro()</code>.
</p>
</dd>
<dt> <code>cpu_opts_init(section *);</code></dt>
<dd><p>(If <code>HAVE_CPU_OPTS</code> is set.)
Gives the cpu module the chance to write out <code>OPTS</code> atoms with
initial settings before the first atom is generated.
</p>
</dd>
<dt> <code>cpu_opts(void *);</code></dt>
<dd><p>(If <code>HAVE_CPU_OPTS</code> is set.)
Apply option modifications from an <code>OPTS</code> atom. For example:
change cpu type or optimization flags.
</p>
</dd>
<dt> <code>print_cpu_opts(FILE *,void *);</code></dt>
<dd><p>(If <code>HAVE_CPU_OPTS</code> is set.)
Called from <code>print_atom()</code> to print an <code>OPTS</code> atom&rsquo;s contents.
</p>
</dd>
</dl>


<hr size="6">
<a name="Output-modules"></a>
<h2 class="section">23.6 Output modules</h2>

<p>Output modules can be chosen at runtime rather than compile time. Therefore,
several output modules are linked into one vasm executable and their
structure differs somewhat from syntax and cpu modules.
</p>
<p>Usually, an output module for some object format <code>fmt</code> should be contained
in a file &lsquo;<tt>output_&lt;fmt&gt;.c</tt>&rsquo; (it may use/include other files if necessary).
To automatically include this format in the build process, the &lsquo;<tt>make.rules</tt>&rsquo;
has to be extended. The module should be added to the <code>OBJS</code> variable
at the start of &lsquo;<tt>make.rules</tt>&rsquo;. Also, a dependency line should be added
(see the existing output modules).
</p>
<p>An output module must only export a single function which will return
pointers to necessary data/functions. This function should have the
following prototype:
</p><table><tr><td>&nbsp;</td><td><pre class="example">int init_output_&lt;fmt&gt;(
      char **copyright,
      void (**write_object)(FILE *,section *,symbol *),
      int (**output_args)(char *)
    );
</pre></td></tr></table>

<p>In case of an error, zero must be returned.
Otherwise, It should perform all necessary initializations, return non-zero
and return the following output parameters via the pointers passed as arguments:
</p>
<dl compact="compact">
<dt> <code>copyright</code></dt>
<dd><p>A pointer to the copyright string.
</p>
</dd>
<dt> <code>write_object</code></dt>
<dd><p>A pointer to a function emitting the output. It will be called after the
assembler has completed and will receive pointers to the output file,
to the first section of the section list and to the first symbol
in the symbol list. See the section on general data structures for further
details.
</p>

</dd>
<dt> <code>output_args</code></dt>
<dd><p>A pointer to a function checking arguments. It will be called with all
command line arguments (unless already handled by other modules). If the
output module recognizes an appropriate option, it has to handle it
and return non-zero. If it is not an option relevant to this output module,
zero must be returned.
</p>
</dd>
</dl>

<p>At last, a call to the <code>output_init_&lt;fmt&gt;</code> has to be added in the
<code>init_output()</code> function in &lsquo;<tt>vasm.c</tt>&rsquo; (should be self-explanatory).
</p>
<p>Some remarks:
</p><ul class="toc">
<li>-
Some output modules can not handle all supported CPUs. Nevertheless,
they have to be written in a way that they can be compiled. If code
references CPU-specifics, they have to be enclosed in
<code>#ifdef VASM_CPU_MYCPU</code> ... <code>#endif</code> or similar.

<p>Also, if the selected CPU is not supported, the init function should fail.
</p>
</li><li>-
Error/warning messages can be emitted with the <code>output_error</code> function.
As all output modules are linked together, they have a common list of error
messages in the file &lsquo;<tt>output_errors.h</tt>&rsquo;. If a new message is needed, this
file has to be extended (see the section on general data structures for
details).

</li><li>-
<code>vasm</code> has a mechanism to specify rather complex relocations in a
standard way (see the section on general data structures). They can be
extended with CPU specific relocations, but usually CPU modules will
try to create standard relocations (sometimes several standard relocations
can be used to implement a CPU specific relocation). An output
module should try to find appropriate relocations supported by the
object format. The goal is to avoid special CPU specific
relocations as much as possible.

</li></ul>

<p>Volker Barthelmann                                      vb@compilers.de
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Interface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="vasm_0.html#General-9" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="vasm_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="vasm_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Luis Panadero Guardeño</em> on <em>January 13, 2015</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
